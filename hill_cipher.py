# -*- coding: utf-8 -*-
"""Hill_Cipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tyoVbPyYl1pfTXKOZq-u5l_cgrAEU9WY
"""

import numpy as np
import math
import re


def split_sentences(text):
    words = re.findall(r"(\S+|\s+)", text)                              # findall() splits on the basis of given pattern.\S+ matches one or more non-whitespace character while \s+ matches one or more whitespace character. without '+' each character will be stored separately
    return words

def key_generation():
    while True:                                                         # loop runs till a non-singular matrix is generated
        random_matrix = np.random.randint(32, 127, size=(3, 3))         # random matrix of size 3x3 is generated with values from 32 to 126
        if np.linalg.det(random_matrix) != 0:                           # checks its determinant. determinant != 0 means it is non-singular
            return random_matrix

def key_inverse(key_matrix):
    return np.linalg.inv(key_matrix)                                    # using numpy module to calculate inverse

def matrix_generation(words):
    for word in words:                                                  # extract each word from list 'words' containing the words of inputed sentence
        l = len(word)
        x = math.ceil(l/3)                                              # to make sure matrix generated is of size (n,3) so that multiplication with key matrix is possible; represents rows
        matrix_numbers = []
        #print(f"word: {word}")
        for i in range(len(word)):                                      # changing each character in a word into its corresponding ASCII code
            matrix_numbers.append(ord(word[i]))
            #print(f"i: {i}")
        if len(matrix_numbers)!=x*3:                                    # if number of rows is not multiple of 3, then pad as many 0's to make it a multiple of 3
            rem = (x*3) - len(matrix_numbers)
            for i in range(rem):
                matrix_numbers.append(0)

        word_array = np.array(matrix_numbers)                           # converting the list of ASCII code present in list 'matrix_numbers' representing a word of inputed sentence to an array
        word_matrix = word_array.reshape(x,3)                           # converting array to a matrix (word into matrix)
        words_matrices.append(word_matrix)                              # appending the matrix to list 'words_matrices'

        matrix_numbers.clear()                                          # clearing the list 'matrix_numbers' so that it can be used for the next word
    #print(words_matrices)

def matrix_multiplication(words_matrices,key_matrix):
    for y in words_matrices:
        cipher_matrices.append(np.dot(y,key_matrix))                    # each matrix stored in list 'word_martrices' is multiplied with key matrix. creates list 'cipher_matrices'
        cipher_text_matrices.append((np.dot(y,key_matrix)%95)+32)       # normalises the multiplied numbers to the ascii range
        # x = np.dot(y,key_matrix)
        # cipher_matrices.append(x.tolist())

def decrypt_matrix(cipher_matrices,inverse_key):
    text_again = []                                                     # will store the matrices we get after multiplying each cipher matrix with the key inverse.
    for z in cipher_matrices:
        text_again.append(np.dot(z,inverse_key))                        # creates list 'text_again' comprising of result of multiplication with inverse
        # x = np.dot(z,inverse_key)
        # text_again.append(x.tolist())
    for i in range(len(text_again)):                                    # each matrix in 'text_again' should be equal to matrices in list 'words_matrices' which is not the case here (somehow we are getting close values but not exact)
        for j in range(len(text_again[i])):
            for k in range(len(text_again[i][j])):
                #print(f"type:{type(text_again[i][j][k])}")
                x = round(float(text_again[i][j][k]))                   # rounding off each value in 'text_again' so that values match with values in list 'words_matrices'. creates list 'text_codes'
                if x!=0:
                    text_codes.append(x)                                # removing 0, as console prints ASCII 0 = NULL as spaces, and we donot want extra spaces

def cipher(cipher_text_matrices):
    for i in range(len(cipher_text_matrices)):                          # creating list 'cipher_text_codes' which will contain ASCII values of the cipher text
        for j in range(len(cipher_text_matrices[i])):
            for k in range(len(cipher_text_matrices[i][j])):
                #print(f"type:{type(text_again[i][j][k])}")
                x = round(float(cipher_text_matrices[i][j][k]))
                if x!=0:
                    cipher_text_codes.append(x)

def generate(codes):
    string=''
    for i in range(len(codes)):
        string+=(chr(codes[i]))                                         # generates the cipher text and original text from each code from list 'cipher_text_codes' and 'text_codes'
    return string



text = input("Enter Text: ")
words_list = split_sentences(text)                                      # spilts the sentence to contain each word (and spaces) separately as individual values
words_matrices = []                                                     # will hold each word in its matrix format.
cipher_matrices = []                                                    # will hold the cipher matrices we get after multiplying each word matrix with the key matrix
text_codes = []                                                         # will hold the deciphered values of cipher matrices, used to get original text back
cipher_text_matrices = []
cipher_text_codes = []


#print(f"words: {words_list}")
key_matrix = key_generation()                                           # generates the key matrix used for encryption
#print(f"key matrix:{key_matrix}")
inverse_key = key_inverse(key_matrix)                                   # generates inverse of key matrix used for deryption
#print(f"inverse key:{inverse_key}")
matrix_generation(words_list)                                           # each word converted to matrix. creates the list 'words_matrices'
#print(f"words_matrices: {words_matrices}")
matrix_multiplication(words_matrices,key_matrix)                        # each word matrix multiplied with key matrix. creates the list 'cipher_matrices'
#print(f"cipher_matrices: {cipher_matrices}")
cipher(cipher_text_matrices)                                            # creation of cipher_text_codes using normalised matrices (after multiplication)
decrypt_matrix(cipher_matrices,inverse_key)                             # each cipher matrix multiplied with inverse matrix. creates the list 'text_codes' (uses original non normalised matrices we get after multiplication)
#print(f"text_codes: {text_codes}")
print("Encrypted Text:", generate(cipher_text_codes))                   # generates cipher text
print("Decrypted Text:", generate(text_codes))                          # generates the original text back
#print(f"cipher_text_matrices: {cipher_text_matrices}")
#print(f"cipher_text_codes: {cipher_text_codes}")